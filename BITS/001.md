Love where you’re going. Here’s a tight, usable spec that matches your intuition:

# Packet & Flow (your “0000|00|0000”)

**Transitional packet (10 cells):**

```
W3 W2 W1 W0  |  H1 H0  |  E3 E2 E1 E0
  what/where    how/why     echo (copy)
```

- The **double bar** `||` is the **carrier window**—the rotating read/write aperture in motion.
    
- The packet **spins**; you sample it at fixed phase points (quarter/half turns). Bits may flip while in the window by field rules (not static 1/0).
    

# Geometry mapping (binary → field)

## 1) what/where (W3…W0): pick a geometric locus

4 bits = 16 codes. Use them to select **directions** in your polarity lattice.

Two practical options (pick one):

**A. T₄ (cuboctahedron) directions (recommended):**  
12 “one-axis-inverted” full-magnitude vectors: permutations of (–1,+1,+1) and (+1,–1,–1).

- Fits in 16 codes with headroom for sentinels (idle, center, error).
    
- These are the **movement** directions (your “flow shell”).
    

**B. T₃ (polar cube) corners:**  
8 pure ± vectors (±1,±1,±1).

- Simpler, fewer directions.
    

> Either way, W selects a **vector target** in the field (the “geo coord”).

## 2) how/why (H1 H0): choose the operator

Map 2 bits to your four core actions (XOR-free):

- `00` = **Lift** (bias → sign): –0→–1, 0→0, +0→+1
    
- `01` = **Exchange** (flip exactly one axis sign; the “motion” operator)
    
- `10` = **Collapse** (to {0,1}: sign>0→1; ≤0→0)
    
- `11` = **Normalize** (return to {–0,0,+0}: –1→–0, +1→+0)
    

These are precisely the operators that take you among T₀…T₄.

## 3) echo (E3…E0): storage & integrity

- Default: **mirror W** (copy of what/where) for “No-Cloning-safe” persistence.
    
- Upgrade: **Gray-coded W** (one-bit change per step) → detects motion mid-write.
    
- Reserve 1 bit (if needed) for **parity** or **epoch** to detect stale echoes.
    

# Dynamics (bits flip _in_ motion)

You read/write only while the packet’s center `||` passes a node. During that window:

- **Exchange** may flip the minority axis (moving along the T₄ shell).
    
- **Lift** assigns magnitude (prepares geometry).
    
- **Collapse** converts to binary only at I/O edges.
    
- **Normalize** bleeds energy back to the neutral field.
    

### Minimal update rule (per axis a∈{x,y,z})

Let state be one of {–1, –0, 0, +0, +1}. With operator `op`:

```
if op == Lift:       –0→–1, 0→0, +0→+1
if op == Exchange:   flip the axis that differs from (sign of the other two)
if op == Collapse:   –1/–0/0 → 0,   +0/+1 → 1
if op == Normalize:  –1→–0, +1→+0,  0→0
```

> This preserves your **XOR-free** behavior: resolution is by **bias & energy**, not exclusivity.

# Timeline (one spin)

1. **Binary in** → decode to **W/H** (e.g., lookup for W, direct map for H).
    
2. **Lift** (if needed) to place the state on T₁.
    
3. **Exchange** drives motion (T₄ shell) toward target direction (W).
    
4. **Normalize** if you’re handing off to the field again; **Collapse** only at binary I/O.
    
5. **Echo** writes (E=W or Gray(W)) at the storage phase; verify parity/epoch.
    

# Example (walkthrough)

- Input frame: `W=0101 | H=01 | E=0101`
    
    - `W=0101` → T₄ direction, say `(–1,+1,+1)`
        
    - `H=01` → **Exchange**
        
- Current axis signs `(–1,0,+1)` under Exchange: minority is `0` vs the two nonzero; promote 0 toward the differing sign to enter the shell.
    
- After a few windows, state reaches `(–1,+1,+1)`.
    
- **Echo** latches `0101` (or Gray-coded) to storage at commit phase.
    
- At output boundary, apply **Collapse** for binary readout.
    

# Error handling & coherence

- **Desync**: if `E ≠ W` after a full rotation, flag “in-flight”; do not commit.
    
- **Ambiguity**: if multiple axes are zero under Exchange, **Lift** first.
    
- **Stall**: if the state fails to change over N windows, force **Normalize** to re-enter field.
    

# Geometry features you asked to evaluate

- Your **10-bit transitional state** is sufficient to: pick a **direction** (W), define an **action** (H), and **persist** it (E).
    
- **Motion is real** in the model: bits flip _while_ in the `||` window under Exchange/Lift; they are **observable in-flight**, not just static endpoints.
    
- The **4–2–4 split** aligns with: **where/what**, **how/why**, **proof/echo**.
    
- Using **T₄ for W** gives smooth movement (twelve directions) instead of just jumping among eight corners—exactly what you want for “carrier in motion.”
    

# One-sentence caption (put next to your diagram)

> **10-cell carrier:** `W(4)|H(2)|E(4)` — binary unfolds to a geometric direction (W), applies a field operator (H), and writes a Gray/echo copy (E) while the `||` window rotates; bits flip in motion via Lift/Exchange/Normalize, and Collapse occurs only at binary I/O.

If you want, I can also give you a compact lookup table for `W`→(vector) using either the 12 T₄ directions or the 8 T₃ corners, plus a tiny state machine diagram for the `||` window.